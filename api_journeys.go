/*
Planera Resa

Sök och planera resor med Västtrafik

API version: v4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// JourneysApiService JourneysApi service
type JourneysApiService service

type ApiJourneysDetailsReferenceDetailsGetRequest struct {
	ctx context.Context
	ApiService *JourneysApiService
	detailsReference string
	includes *[]VTApiPlaneraResaWebV4ModelsJourneyDetailsIncludeType
	channelIds *[]int32
	productTypes *[]int32
	travellerCategories *[]VTApiPlaneraResaCoreModelsTravellerCategory
}

// The additional information to include in the response.
func (r ApiJourneysDetailsReferenceDetailsGetRequest) Includes(includes []VTApiPlaneraResaWebV4ModelsJourneyDetailsIncludeType) ApiJourneysDetailsReferenceDetailsGetRequest {
	r.includes = &includes
	return r
}

// List of channel ids to include if &#39;ticketsuggestions&#39; is set in the &#39;includes&#39; parameter. Optional parameter.
func (r ApiJourneysDetailsReferenceDetailsGetRequest) ChannelIds(channelIds []int32) ApiJourneysDetailsReferenceDetailsGetRequest {
	r.channelIds = &channelIds
	return r
}

// List of product type ids to include if &#39;ticketsuggestions&#39; is set in the &#39;includes&#39; parameter. Optional parameter.
func (r ApiJourneysDetailsReferenceDetailsGetRequest) ProductTypes(productTypes []int32) ApiJourneysDetailsReferenceDetailsGetRequest {
	r.productTypes = &productTypes
	return r
}

// List of traveller category ids to include if &#39;ticketsuggestions&#39; is set in the &#39;includes&#39; parameter. Optional parameter.
func (r ApiJourneysDetailsReferenceDetailsGetRequest) TravellerCategories(travellerCategories []VTApiPlaneraResaCoreModelsTravellerCategory) ApiJourneysDetailsReferenceDetailsGetRequest {
	r.travellerCategories = &travellerCategories
	return r
}

func (r ApiJourneysDetailsReferenceDetailsGetRequest) Execute() (*VTApiPlaneraResaWebV4ModelsJourneyDetailsJourneyDetailsApiModel, *http.Response, error) {
	return r.ApiService.JourneysDetailsReferenceDetailsGetExecute(r)
}

/*
JourneysDetailsReferenceDetailsGet Returns details about a journey.

Sample request:

    GET /journeys/{detailsReference}/details?includes=ticketsuggestions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param detailsReference The reference to the journey, received from the search journeys query. A detailsReference is only valid during the same day as it was generated.
 @return ApiJourneysDetailsReferenceDetailsGetRequest
*/
func (a *JourneysApiService) JourneysDetailsReferenceDetailsGet(ctx context.Context, detailsReference string) ApiJourneysDetailsReferenceDetailsGetRequest {
	return ApiJourneysDetailsReferenceDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		detailsReference: detailsReference,
	}
}

// Execute executes the request
//  @return VTApiPlaneraResaWebV4ModelsJourneyDetailsJourneyDetailsApiModel
func (a *JourneysApiService) JourneysDetailsReferenceDetailsGetExecute(r ApiJourneysDetailsReferenceDetailsGetRequest) (*VTApiPlaneraResaWebV4ModelsJourneyDetailsJourneyDetailsApiModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VTApiPlaneraResaWebV4ModelsJourneyDetailsJourneyDetailsApiModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JourneysApiService.JourneysDetailsReferenceDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/journeys/{detailsReference}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"detailsReference"+"}", url.PathEscape(parameterValueToString(r.detailsReference, "detailsReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "multi")
		}
	}
	if r.channelIds != nil {
		t := *r.channelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelIds", t, "multi")
		}
	}
	if r.productTypes != nil {
		t := *r.productTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productTypes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productTypes", t, "multi")
		}
	}
	if r.travellerCategories != nil {
		t := *r.travellerCategories
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "travellerCategories", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "travellerCategories", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v VTApiPlaneraResaWebV4ModelsApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJourneysGetRequest struct {
	ctx context.Context
	ApiService *JourneysApiService
	originGid *string
	originName *string
	originLatitude *float64
	originLongitude *float64
	destinationGid *string
	destinationName *string
	destinationLatitude *float64
	destinationLongitude *float64
	dateTime *time.Time
	dateTimeRelatesTo *VTApiPlaneraResaCoreModelsDateTimeRelatesToType
	paginationReference *string
	limit *int32
	transportModes *[]VTApiPlaneraResaWebV4ModelsJourneyTransportMode
	transportSubModes *[]VTApiPlaneraResaWebV4ModelsJourneyTransportSubMode
	onlyDirectConnections *bool
	includeNearbyStopAreas *bool
	viaGid *int64
	originWalk *string
	destWalk *string
	originBike *string
	destBike *string
	totalBike *string
	originCar *string
	destCar *string
	originPark *string
	destPark *string
	interchangeDurationInMinutes *int32
	includeOccupancy *bool
}

// The 16-digit Västtrafik gid of the origin location (which could be either a stop area (e.g. &#39;9021014001760000&#39;), a stop point (e.g. &#39;9022014001760004&#39;) or meta-station (e.g. &#39;0000000800000022&#39;)).
func (r ApiJourneysGetRequest) OriginGid(originGid string) ApiJourneysGetRequest {
	r.originGid = &originGid
	return r
}

// The name of the origin location. The maximum length allowed is 256 characters.
func (r ApiJourneysGetRequest) OriginName(originName string) ApiJourneysGetRequest {
	r.originName = &originName
	return r
}

// The latitude of the origin location.
func (r ApiJourneysGetRequest) OriginLatitude(originLatitude float64) ApiJourneysGetRequest {
	r.originLatitude = &originLatitude
	return r
}

// The longitude of the origin location.
func (r ApiJourneysGetRequest) OriginLongitude(originLongitude float64) ApiJourneysGetRequest {
	r.originLongitude = &originLongitude
	return r
}

// The 16-digit Västtrafik gid of the destination location (which could be either a stop area, stop point or meta-station).
func (r ApiJourneysGetRequest) DestinationGid(destinationGid string) ApiJourneysGetRequest {
	r.destinationGid = &destinationGid
	return r
}

// The name of the destination location. The maximum length allowed is 256 characters.
func (r ApiJourneysGetRequest) DestinationName(destinationName string) ApiJourneysGetRequest {
	r.destinationName = &destinationName
	return r
}

// The latitude of the destination location.
func (r ApiJourneysGetRequest) DestinationLatitude(destinationLatitude float64) ApiJourneysGetRequest {
	r.destinationLatitude = &destinationLatitude
	return r
}

// The longitude of the destination location.
func (r ApiJourneysGetRequest) DestinationLongitude(destinationLongitude float64) ApiJourneysGetRequest {
	r.destinationLongitude = &destinationLongitude
	return r
}

// The datetime for which to search journeys. Must be specified in RFC 3339 format or be null which means that the current time on the server is used. The related dateTimeRelatesTo parameter specifies if the time is related to the arrival or departure.
func (r ApiJourneysGetRequest) DateTime(dateTime time.Time) ApiJourneysGetRequest {
	r.dateTime = &dateTime
	return r
}

// Specifies if the datetime is related to the departure or arrival of the journey.
func (r ApiJourneysGetRequest) DateTimeRelatesTo(dateTimeRelatesTo VTApiPlaneraResaCoreModelsDateTimeRelatesToType) ApiJourneysGetRequest {
	r.dateTimeRelatesTo = &dateTimeRelatesTo
	return r
}

// Pagination reference from a previous search.
func (r ApiJourneysGetRequest) PaginationReference(paginationReference string) ApiJourneysGetRequest {
	r.paginationReference = &paginationReference
	return r
}

// The number of results to return. Not guaranteed to return the specified number of results and usually not more than 7 results.
func (r ApiJourneysGetRequest) Limit(limit int32) ApiJourneysGetRequest {
	r.limit = &limit
	return r
}

// The transport modes to include when searching for journeys, if none specified all transport modes are included.
func (r ApiJourneysGetRequest) TransportModes(transportModes []VTApiPlaneraResaWebV4ModelsJourneyTransportMode) ApiJourneysGetRequest {
	r.transportModes = &transportModes
	return r
}

// The transport sub modes to include when searching for journeys, if none specified all transport sub modes are included. Only supported in combination with transportMode &#39;train&#39;.
func (r ApiJourneysGetRequest) TransportSubModes(transportSubModes []VTApiPlaneraResaWebV4ModelsJourneyTransportSubMode) ApiJourneysGetRequest {
	r.transportSubModes = &transportSubModes
	return r
}

// Only include direct connections, e.g. journeys with one trip leg.
func (r ApiJourneysGetRequest) OnlyDirectConnections(onlyDirectConnections bool) ApiJourneysGetRequest {
	r.onlyDirectConnections = &onlyDirectConnections
	return r
}

// Includes nearby stop areas when searching for a journey to or from a stop area or stop point. This means that the search algorithm will take additional stop points of other stop areas nearby the given start and destination stop area into account. These additional stop points are reachable by walk. E.g when true a journey suggestion may include a departure access link (initial walking leg) to a stop point of a stop area close by the specified origin stop area.
func (r ApiJourneysGetRequest) IncludeNearbyStopAreas(includeNearbyStopAreas bool) ApiJourneysGetRequest {
	r.includeNearbyStopAreas = &includeNearbyStopAreas
	return r
}

// The 16-digit Västtrafik gid of the via location (which must be a stop area).
func (r ApiJourneysGetRequest) ViaGid(viaGid int64) ApiJourneysGetRequest {
	r.viaGid = &viaGid
	return r
}

// Enables/disables using footpaths in the beginning of a trip when searching from an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable walk with a minimum distance of 0 meters and a maximum distance of 3 kilometers, set the parameter originWalk&#x3D;1,0,3000. If default distances should be used, skip the values, e.g 1,,. This will enable walk with the default minimum (0 meters) and the default maximum (2000 meters).
func (r ApiJourneysGetRequest) OriginWalk(originWalk string) ApiJourneysGetRequest {
	r.originWalk = &originWalk
	return r
}

// Enables/disables using footpaths at the end of a trip when searching to an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable walk with a minimum distance of 0 meters and a maximum distance of 3 kilometers, set the parameter destWalk&#x3D;1,0,3000. If default distances should be used, skip the values, e.g 1,,. This will enable walk with the default minimum (0 meters) and the default maximum (2000 meters).
func (r ApiJourneysGetRequest) DestWalk(destWalk string) ApiJourneysGetRequest {
	r.destWalk = &destWalk
	return r
}

// Enables/disables using bike paths in the beginning of a trip when searching from an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable bike with a minimum distance of 1000 meters and a maximum distance of 5 kilometers, set the parameter originBike&#x3D;1,1000,5000. If default distances should be used, skip the values, e.g 1,,. This will enable bike with the default minimum (0 meters) and the default maximum (3000 meters).
func (r ApiJourneysGetRequest) OriginBike(originBike string) ApiJourneysGetRequest {
	r.originBike = &originBike
	return r
}

// Enables/disables using bike paths at the end of a trip when searching to an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable bike with a minimum distance of 1000 meters and a maximum distance of 5 kilometers, set the parameter destBike&#x3D;1,1000,5000. If default distances should be used, skip the values, e.g 1,,. This will enable bike with the default minimum (0 meters) and the default maximum (3000 meters).
func (r ApiJourneysGetRequest) DestBike(destBike string) ApiJourneysGetRequest {
	r.destBike = &destBike
	return r
}

// Enables/disables using bike routes for the whole trip. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable bike with a minimum distance of 0 meters and a maximum distance of 20 kilometers, set the parameter totalBike&#x3D;1,0,20000. If default distances should be used, skip the values, e.g 1,,. This will enable bike with the default minimum (0 meters) and the default maximum (25000 meters).
func (r ApiJourneysGetRequest) TotalBike(totalBike string) ApiJourneysGetRequest {
	r.totalBike = &totalBike
	return r
}

// Enables/disables using car in the beginning of a trip when searching from an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable car with a minimum distance of 2000 meters and a maximum distance of 7 kilometers, set the parameter origincar&#x3D;1,2000,7000. If default distances should be used, skip the values, e.g 1,,. This will enable car with the default minimum (0 meters) and the default maximum (5000 meters).
func (r ApiJourneysGetRequest) OriginCar(originCar string) ApiJourneysGetRequest {
	r.originCar = &originCar
	return r
}

// Enables/disables using car at the end of a trip when searching to an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable car with a minimum distance of 2000 meters and a maximum distance of 7 kilometers, set the parameter destCar&#x3D;1,2000,7000. If default distances should be used, skip the values, e.g 1,,. This will enable car with the default minimum (0 meters) and the default maximum (5000 meters).
func (r ApiJourneysGetRequest) DestCar(destCar string) ApiJourneysGetRequest {
	r.destCar = &destCar
	return r
}

// Enables/disables using Park and Ride in the beginning of a trip when searching from an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable Park and Ride with a minimum distance of 3000 meters and a maximum distance of 70 kilometers, set the parameter originPark&#x3D;1,3000,70000. If default distances should be used, skip the values, e.g 1,,. This will enable Park and Ride with the default minimum (2000 meters) and the default maximum (50000 meters).
func (r ApiJourneysGetRequest) OriginPark(originPark string) ApiJourneysGetRequest {
	r.originPark = &originPark
	return r
}

// Enables/disables using Park and Ride at the end of a trip when searching to an address. To fine-tune the minimum and/or maximum distance to the next public transport station, provide these values separated by comma. The values are expressed in meters. To enable Park and Ride with a minimum distance of 3000 meters and a maximum distance of 70 kilometers, set the parameter destPark&#x3D;1,3000,70000. If default distances should be used, skip the values, e.g 1,,. This will enable Park and Ride with the default minimum (2000 meters) and the default maximum (50000 meters).
func (r ApiJourneysGetRequest) DestPark(destPark string) ApiJourneysGetRequest {
	r.destPark = &destPark
	return r
}

// The minimum number of minutes between arrival and departure for a connection to be valid and the trip included in the search results, ignoring the default value.
func (r ApiJourneysGetRequest) InterchangeDurationInMinutes(interchangeDurationInMinutes int32) ApiJourneysGetRequest {
	r.interchangeDurationInMinutes = &interchangeDurationInMinutes
	return r
}

// Includes occupancy in journey.
func (r ApiJourneysGetRequest) IncludeOccupancy(includeOccupancy bool) ApiJourneysGetRequest {
	r.includeOccupancy = &includeOccupancy
	return r
}

func (r ApiJourneysGetRequest) Execute() (*VTApiPlaneraResaWebV4ModelsJourneysGetJourneysResponse, *http.Response, error) {
	return r.ApiService.JourneysGetExecute(r)
}

/*
JourneysGet Returns journeys matching the specified search parameters.

For an origin or destination to be valid, either a gid or a combination of latitude and longitude must be specified. OriginName and destinationName are optional in combination with latitude and longitude.

Sample request:

    GET /journeys?originGid=9021014001760000&destinationGid=9021014003980000

or

    GET /journeys?originName=Sadelsten,+V%C3%A5rg%C3%A5rda&originLongitude=12.63308&originLatitude=58.028237&destinationLongitude=11.930897&destinationLatitude=57.586085&destinationName=%C3%85sdammsstigen,+427+36+Billdal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJourneysGetRequest
*/
func (a *JourneysApiService) JourneysGet(ctx context.Context) ApiJourneysGetRequest {
	return ApiJourneysGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VTApiPlaneraResaWebV4ModelsJourneysGetJourneysResponse
func (a *JourneysApiService) JourneysGetExecute(r ApiJourneysGetRequest) (*VTApiPlaneraResaWebV4ModelsJourneysGetJourneysResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VTApiPlaneraResaWebV4ModelsJourneysGetJourneysResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JourneysApiService.JourneysGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/journeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.originGid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originGid", r.originGid, "")
	}
	if r.originName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originName", r.originName, "")
	}
	if r.originLatitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originLatitude", r.originLatitude, "")
	}
	if r.originLongitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originLongitude", r.originLongitude, "")
	}
	if r.destinationGid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationGid", r.destinationGid, "")
	}
	if r.destinationName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationName", r.destinationName, "")
	}
	if r.destinationLatitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationLatitude", r.destinationLatitude, "")
	}
	if r.destinationLongitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationLongitude", r.destinationLongitude, "")
	}
	if r.dateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateTime", r.dateTime, "")
	}
	if r.dateTimeRelatesTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateTimeRelatesTo", r.dateTimeRelatesTo, "")
	}
	if r.paginationReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginationReference", r.paginationReference, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.transportModes != nil {
		t := *r.transportModes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportModes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportModes", t, "multi")
		}
	}
	if r.transportSubModes != nil {
		t := *r.transportSubModes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transportSubModes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transportSubModes", t, "multi")
		}
	}
	if r.onlyDirectConnections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyDirectConnections", r.onlyDirectConnections, "")
	}
	if r.includeNearbyStopAreas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNearbyStopAreas", r.includeNearbyStopAreas, "")
	}
	if r.viaGid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viaGid", r.viaGid, "")
	}
	if r.originWalk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originWalk", r.originWalk, "")
	}
	if r.destWalk != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destWalk", r.destWalk, "")
	}
	if r.originBike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originBike", r.originBike, "")
	}
	if r.destBike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destBike", r.destBike, "")
	}
	if r.totalBike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBike", r.totalBike, "")
	}
	if r.originCar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCar", r.originCar, "")
	}
	if r.destCar != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destCar", r.destCar, "")
	}
	if r.originPark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originPark", r.originPark, "")
	}
	if r.destPark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destPark", r.destPark, "")
	}
	if r.interchangeDurationInMinutes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interchangeDurationInMinutes", r.interchangeDurationInMinutes, "")
	}
	if r.includeOccupancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOccupancy", r.includeOccupancy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v VTApiPlaneraResaWebV4ModelsApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJourneysReconstructGetRequest struct {
	ctx context.Context
	ApiService *JourneysApiService
	ref *string
	includeOccupancy *bool
}

// The reconstruction reference. A reconstructionReference is valid as long as the original journey search is valid.
func (r ApiJourneysReconstructGetRequest) Ref(ref string) ApiJourneysReconstructGetRequest {
	r.ref = &ref
	return r
}

// Includes occupancy in journey.
func (r ApiJourneysReconstructGetRequest) IncludeOccupancy(includeOccupancy bool) ApiJourneysReconstructGetRequest {
	r.includeOccupancy = &includeOccupancy
	return r
}

func (r ApiJourneysReconstructGetRequest) Execute() (*VTApiPlaneraResaWebV4ModelsJourneysJourneyApiModel, *http.Response, error) {
	return r.ApiService.JourneysReconstructGetExecute(r)
}

/*
JourneysReconstructGet Reconstructs a journey based on the given reconstruction reference, received from the search journeys query.

Sample request:

    GET /journeys/reconstruct?ref=¶HKI¶T$A=1@O=Brunnsparken, Göteborg@L=1760003@a=128@$A=1@O=Korsvägen, Göteborg@L=3980004@a=128@$202206131358$202206131406$Spå    4$$1$$$$$$¶KRCC¶#VE#1#

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJourneysReconstructGetRequest
*/
func (a *JourneysApiService) JourneysReconstructGet(ctx context.Context) ApiJourneysReconstructGetRequest {
	return ApiJourneysReconstructGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VTApiPlaneraResaWebV4ModelsJourneysJourneyApiModel
func (a *JourneysApiService) JourneysReconstructGetExecute(r ApiJourneysReconstructGetRequest) (*VTApiPlaneraResaWebV4ModelsJourneysJourneyApiModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VTApiPlaneraResaWebV4ModelsJourneysJourneyApiModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JourneysApiService.JourneysReconstructGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/journeys/reconstruct"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ref == nil {
		return localVarReturnValue, nil, reportError("ref is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "")
	if r.includeOccupancy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOccupancy", r.includeOccupancy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v VTApiPlaneraResaWebV4ModelsApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJourneysValidTimeIntervalGetRequest struct {
	ctx context.Context
	ApiService *JourneysApiService
}

func (r ApiJourneysValidTimeIntervalGetRequest) Execute() (*VTApiPlaneraResaWebV4ModelsValidTimeIntervalApiModel, *http.Response, error) {
	return r.ApiService.JourneysValidTimeIntervalGetExecute(r)
}

/*
JourneysValidTimeIntervalGet Returns a time interval for when journey data is available.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJourneysValidTimeIntervalGetRequest
*/
func (a *JourneysApiService) JourneysValidTimeIntervalGet(ctx context.Context) ApiJourneysValidTimeIntervalGetRequest {
	return ApiJourneysValidTimeIntervalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VTApiPlaneraResaWebV4ModelsValidTimeIntervalApiModel
func (a *JourneysApiService) JourneysValidTimeIntervalGetExecute(r ApiJourneysValidTimeIntervalGetRequest) (*VTApiPlaneraResaWebV4ModelsValidTimeIntervalApiModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VTApiPlaneraResaWebV4ModelsValidTimeIntervalApiModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JourneysApiService.JourneysValidTimeIntervalGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/journeys/valid-time-interval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MicrosoftAspNetCoreMvcProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
